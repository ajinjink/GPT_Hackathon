import imaplib
import email
from email.header import decode_header, make_header
from langchain.memory import ConversationBufferMemory
from langchain.prompts import PromptTemplate
from langchain.chains import ConversationChain
from langchain_openai import ChatOpenAI
from email.mime.text import MIMEText
import smtplib

# Gmail 로그인 정보
user = 'herakwon1124@hanyang.ac.kr'
password = 'frfc ijyf lmek skyr'  # 앱 비밀번호 사용

# LangChain 설정
llm = ChatOpenAI(temperature=0)
template = """
당신은 매우 공손하고 성실한 대학생으로 행동해야 합니다. 
다음 메일을 교수님께 답장하는 형식으로 작성하세요.

대화 히스토리:
{history}

교수님의 메일:
{input}

학생의 답장:
"""
prompt = PromptTemplate(input_variables=["history", "input"], template=template)
memory = ConversationBufferMemory()
conversation = ConversationChain(llm=llm, memory=memory, prompt=prompt)

# IMAP 연결 및 이메일 읽기
imap = imaplib.IMAP4_SSL("imap.gmail.com")
imap.login(user, password)
imap.select("INBOX")

# @hanyang.ac.kr로 필터링된 이메일 검색
status, messages = imap.search(None, 'FROM', '@hanyang.ac.kr')
messages = messages[0].split()

# 히스토리 생성
history_list = []
for mail in messages[-5:]:  # 최근 5개의 이메일만 가져오기
    status, msg = imap.fetch(mail, "(RFC822)")
    raw_email = msg[0][1]
    email_message = email.message_from_bytes(raw_email)

    # 보낸사람
    fr = make_header(decode_header(email_message.get('From')))
    fr_str = str(fr)

    # 메일 제목
    subject = make_header(decode_header(email_message.get('Subject')))
    subject_str = str(subject)

    # 메일 내용 초기화
    body = "내용을 가져오지 못했습니다."

    # 메일 내용 추출
    if email_message.is_multipart():
        for part in email_message.walk():
            ctype = part.get_content_type()
            cdispo = str(part.get('Content-Disposition'))
            if ctype == 'text/plain' and 'attachment' not in cdispo:
                body = part.get_payload(decode=True).decode('utf-8')
                break
    else:
        try:
            body = email_message.get_payload(decode=True).decode('utf-8')
        except Exception as e:
            print(f"Error decoding body: {e}")

    # 히스토리 형식
    history_list.append(f"From: {fr_str}\nSubject: {subject_str}\nBody: {body}\n")

# 히스토리를 하나의 문자열로 합치기
history = "\n\n---\n\n".join(history_list)

# 교수님의 가장 최근 메일 추출
if messages:
    recent = messages[-1]
    status, msg = imap.fetch(recent, "(RFC822)")
    raw_email = msg[0][1]
    email_message = email.message_from_bytes(raw_email)
    if email_message.is_multipart():
        for part in email_message.walk():
            ctype = part.get_content_type()
            cdispo = str(part.get('Content-Disposition'))
            if ctype == 'text/plain' and 'attachment' not in cdispo:
                input_body = part.get_payload(decode=True).decode('utf-8')
                break
    else:
        input_body = email_message.get_payload(decode=True).decode('utf-8')
else:
    input_body = "교수님 메일이 없습니다."
imap.close()
imap.logout()

# LangChain으로 답장 생성
response = conversation.predict(
    input=input_body,
    history=history
)
print("Generated Response:")
print(response)

# 보낸사람 및 수신자 정보
if messages:
    fr = make_header(decode_header(email_message.get('From')))
    receiver = str(fr).split('<')[-1].strip('>')

    # SMTP로 답장 보내기
    smtp = smtplib.SMTP('smtp.gmail.com', 587)
    smtp.ehlo()
    smtp.starttls()
    smtp.login(user, password)

    msg = MIMEText(response, 'plain')
    msg['Subject'] = 'Re: ' + str(make_header(decode_header(email_message.get('Subject'))))
    msg['From'] = user
    msg['To'] = receiver

    smtp.sendmail(user, receiver, msg.as_string())
    smtp.quit()

    print("답장을 보냈습니다.")
else:
    print("보낼 메일이 없습니다.")
